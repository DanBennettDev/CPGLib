<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CPG Rhythm Engine: MatsuokaEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CPG Rhythm Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMatsuokaEngine-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MatsuokaEngine Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Engine: Main interface for controlling and calculating the <a class="el" href="classCPG.html" title="Engine: Matsuoka Oscillator Central Pattern Generator Template Class. ">CPG</a> network.  
 <a href="classMatsuokaEngine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MatsuokaEngine_8h_source.html">MatsuokaEngine.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad8f471b2f1ca479174d5514b9a3597ec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#ad8f471b2f1ca479174d5514b9a3597ec">externalSync</a> { <a class="el" href="classMatsuokaEngine.html#ad8f471b2f1ca479174d5514b9a3597eca4c1d8f9abc3142b344a24624ea7c0a96">none</a>, 
<a class="el" href="classMatsuokaEngine.html#ad8f471b2f1ca479174d5514b9a3597ecaf17848b3aa2effcdfd4576b7723ffc7b">driving</a>, 
<a class="el" href="classMatsuokaEngine.html#ad8f471b2f1ca479174d5514b9a3597eca66dfc95cb0e1248f30385a100203920c">reseting</a>
 }</td></tr>
<tr class="separator:ad8f471b2f1ca479174d5514b9a3597ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811a5449f07004a2eb6b34e8c9bd862f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a811a5449f07004a2eb6b34e8c9bd862f">input</a> = <a class="el" href="structCPG_1_1input.html">CPG::input</a></td></tr>
<tr class="separator:a811a5449f07004a2eb6b34e8c9bd862f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf2fcb6ddd3b8edc414753248b95fc2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#acbf2fcb6ddd3b8edc414753248b95fc2">synchMode</a> = <a class="el" href="classMatsuNode.html#a725e228db39b8842f851ddf88f640bed">MatsuNode::synchMode</a></td></tr>
<tr class="separator:acbf2fcb6ddd3b8edc414753248b95fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09035e4918ce82c9378821c88375f843"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a09035e4918ce82c9378821c88375f843">outputEvent</a> = <a class="el" href="structQuantisedEventQueue_1_1outputEvent.html">QuantisedEventQueue::outputEvent</a></td></tr>
<tr class="separator:a09035e4918ce82c9378821c88375f843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf41ce5bf63099a1d864e4eb91527cb5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#aaf41ce5bf63099a1d864e4eb91527cb5">gridType</a> = <a class="el" href="classQuantisedEventQueue.html#ae186d50bd503038452edbbdd0c7c259e">QuantisedEventQueue::gridType</a></td></tr>
<tr class="separator:aaf41ce5bf63099a1d864e4eb91527cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a25f70ceddea44651433ea8547b332ecf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a25f70ceddea44651433ea8547b332ecf">MatsuokaEngine</a> ()</td></tr>
<tr class="separator:a25f70ceddea44651433ea8547b332ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d26cc1bf5144ea89611377701716fea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a4d26cc1bf5144ea89611377701716fea">MatsuokaEngine</a> (unsigned sampleRate, bool eventOnRise=true, bool eventOnFall=false, bool fireOnPeak=false)</td></tr>
<tr class="separator:a4d26cc1bf5144ea89611377701716fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c8d7fd6eb27c8a8dae7e5fa3742ff9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#ab0c8d7fd6eb27c8a8dae7e5fa3742ff9">MatsuokaEngine</a> (const <a class="el" href="classMatsuokaEngine.html">MatsuokaEngine</a> &amp;rhs)</td></tr>
<tr class="separator:ab0c8d7fd6eb27c8a8dae7e5fa3742ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa468dc0814f1ad92594f7a4d5abd00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a4fa468dc0814f1ad92594f7a4d5abd00">step</a> ()</td></tr>
<tr class="memdesc:a4fa468dc0814f1ad92594f7a4d5abd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate one step of network calculations, and populate the event queue,  <a href="#a4fa468dc0814f1ad92594f7a4d5abd00">More...</a><br /></td></tr>
<tr class="separator:a4fa468dc0814f1ad92594f7a4d5abd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12519e69a1b16fe9c07717ded5249cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a12519e69a1b16fe9c07717ded5249cdf">stepBareBones</a> ()</td></tr>
<tr class="memdesc:a12519e69a1b16fe9c07717ded5249cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">no syncing, no quantiser, no freq Compensation Calcs etc.,  <a href="#a12519e69a1b16fe9c07717ded5249cdf">More...</a><br /></td></tr>
<tr class="separator:a12519e69a1b16fe9c07717ded5249cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf2583d11befa98a8a9d74c700635d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#aedf2583d11befa98a8a9d74c700635d6">step</a> (unsigned nodeID)</td></tr>
<tr class="memdesc:aedf2583d11befa98a8a9d74c700635d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">do one calculation step for the indicated node,  <a href="#aedf2583d11befa98a8a9d74c700635d6">More...</a><br /></td></tr>
<tr class="separator:aedf2583d11befa98a8a9d74c700635d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f070a75e9005f6cc1f3c2b33c4baf5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#ae8f070a75e9005f6cc1f3c2b33c4baf5">getNodeList</a> () const</td></tr>
<tr class="memdesc:ae8f070a75e9005f6cc1f3c2b33c4baf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">list ids of all nodes in the network  <a href="#ae8f070a75e9005f6cc1f3c2b33c4baf5">More...</a><br /></td></tr>
<tr class="separator:ae8f070a75e9005f6cc1f3c2b33c4baf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8067a4f72a8376635ce2d61bece1f2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structCPG_1_1input.html">CPG::input</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a7b8067a4f72a8376635ce2d61bece1f2">getInputs</a> (unsigned nodeID) const</td></tr>
<tr class="memdesc:a7b8067a4f72a8376635ce2d61bece1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return details of the inputs from other nodes, into the requested node  <a href="#a7b8067a4f72a8376635ce2d61bece1f2">More...</a><br /></td></tr>
<tr class="separator:a7b8067a4f72a8376635ce2d61bece1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac87afef0c7c99601fa77e2be27b2b74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#aac87afef0c7c99601fa77e2be27b2b74">nodeExists</a> (unsigned nodeID) const</td></tr>
<tr class="memdesc:aac87afef0c7c99601fa77e2be27b2b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the nodeID exists in the network  <a href="#aac87afef0c7c99601fa77e2be27b2b74">More...</a><br /></td></tr>
<tr class="separator:aac87afef0c7c99601fa77e2be27b2b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d2de39e55b20e6c579039eb6081246"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatsuNode.html">MatsuNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#ae2d2de39e55b20e6c579039eb6081246">getNode</a> (unsigned nodeID) const</td></tr>
<tr class="memdesc:ae2d2de39e55b20e6c579039eb6081246"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns const reference to the requested node  <a href="#ae2d2de39e55b20e6c579039eb6081246">More...</a><br /></td></tr>
<tr class="separator:ae2d2de39e55b20e6c579039eb6081246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2757e406e811cbe2e28f8b661cf29472"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a2757e406e811cbe2e28f8b661cf29472">getSampleRate</a> () const</td></tr>
<tr class="memdesc:a2757e406e811cbe2e28f8b661cf29472"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns sample rate of the system  <a href="#a2757e406e811cbe2e28f8b661cf29472">More...</a><br /></td></tr>
<tr class="separator:a2757e406e811cbe2e28f8b661cf29472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb864bf26563682f94ba2e131fb8b793"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#adb864bf26563682f94ba2e131fb8b793">setConnectionWeightScaling</a> (bool on)</td></tr>
<tr class="separator:adb864bf26563682f94ba2e131fb8b793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ad27d38196e2217bdb0b5da35fd095"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#ae2ad27d38196e2217bdb0b5da35fd095">loadConnectionWeightCurve</a> (std::string source)</td></tr>
<tr class="separator:ae2ad27d38196e2217bdb0b5da35fd095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05eb51876bee90334426757a981139b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#ad05eb51876bee90334426757a981139b">loadConnectionWeightCurve</a> (std::vector&lt; float &gt; x, std::vector&lt; float &gt; y)</td></tr>
<tr class="separator:ad05eb51876bee90334426757a981139b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7254e0141ad5763ff6267a8430b30ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#aa7254e0141ad5763ff6267a8430b30ab">setUnityConnectionWeight</a> (float unity)</td></tr>
<tr class="memdesc:aa7254e0141ad5763ff6267a8430b30ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the inputs: sets the incoming value which should map to weight of 1 when setting connections.  <a href="#aa7254e0141ad5763ff6267a8430b30ab">More...</a><br /></td></tr>
<tr class="separator:aa7254e0141ad5763ff6267a8430b30ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d27453816ff152b17b6e744979e994"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a88d27453816ff152b17b6e744979e994">getNodeFrequency</a> (unsigned nodeID) const</td></tr>
<tr class="memdesc:a88d27453816ff152b17b6e744979e994"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the frequency of the requested node  <a href="#a88d27453816ff152b17b6e744979e994">More...</a><br /></td></tr>
<tr class="separator:a88d27453816ff152b17b6e744979e994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d808db0af62f65826f0fcbc47625205"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a5d808db0af62f65826f0fcbc47625205">getNodeParent</a> (unsigned nodeID) const</td></tr>
<tr class="memdesc:a5d808db0af62f65826f0fcbc47625205"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the parent id of the requested node  <a href="#a5d808db0af62f65826f0fcbc47625205">More...</a><br /></td></tr>
<tr class="separator:a5d808db0af62f65826f0fcbc47625205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb45ab4f1c523f979b3d44dd2c5e508"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a8eb45ab4f1c523f979b3d44dd2c5e508">getNodeChildren</a> (unsigned nodeID) const</td></tr>
<tr class="memdesc:a8eb45ab4f1c523f979b3d44dd2c5e508"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns list of IDs of children of the requested node  <a href="#a8eb45ab4f1c523f979b3d44dd2c5e508">More...</a><br /></td></tr>
<tr class="separator:a8eb45ab4f1c523f979b3d44dd2c5e508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ba599f12e55273f7298a70e7f0eff7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a72ba599f12e55273f7298a70e7f0eff7">getNodeOutput</a> (unsigned nodeID, unsigned sampleOffset=0, bool matchQuantiser=false) const</td></tr>
<tr class="separator:a72ba599f12e55273f7298a70e7f0eff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b0d0b8fe0447fba1fe7456dbea4e11"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a87b0d0b8fe0447fba1fe7456dbea4e11">getFrequencyCompensation</a> () const</td></tr>
<tr class="separator:a87b0d0b8fe0447fba1fe7456dbea4e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201de701852d315d3eac20c749b19752"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a201de701852d315d3eac20c749b19752">getNodePhaseOffset</a> (unsigned nodeID) const</td></tr>
<tr class="separator:a201de701852d315d3eac20c749b19752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6857e20e39f058a4145fdc4493df6583"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a6857e20e39f058a4145fdc4493df6583">getNodeSelfNoise</a> (unsigned nodeID) const</td></tr>
<tr class="memdesc:a6857e20e39f058a4145fdc4493df6583"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the amplitude of the noise input to the requested node  <a href="#a6857e20e39f058a4145fdc4493df6583">More...</a><br /></td></tr>
<tr class="separator:a6857e20e39f058a4145fdc4493df6583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7aa58c722f9bce30724d4a62c72374"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a0f7aa58c722f9bce30724d4a62c72374">getNodeInputPhase</a> (unsigned nodeID, unsigned inputID) const</td></tr>
<tr class="memdesc:a0f7aa58c722f9bce30724d4a62c72374"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the phase offset applied to the signal connection between nodes inputID and nodeID (0-1)  <a href="#a0f7aa58c722f9bce30724d4a62c72374">More...</a><br /></td></tr>
<tr class="separator:a0f7aa58c722f9bce30724d4a62c72374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70444163eee59d0df5b282bb8696f5a1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classMatsuokaEngine.html#a09035e4918ce82c9378821c88375f843">outputEvent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a70444163eee59d0df5b282bb8696f5a1">getEvents</a> ()</td></tr>
<tr class="memdesc:a70444163eee59d0df5b282bb8696f5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector of queued events and clears the event queue.  <a href="#a70444163eee59d0df5b282bb8696f5a1">More...</a><br /></td></tr>
<tr class="separator:a70444163eee59d0df5b282bb8696f5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d6295dfa0d28e3bc9d743e763d6ee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a68d6295dfa0d28e3bc9d743e763d6ee9">calibrate</a> ()</td></tr>
<tr class="separator:a68d6295dfa0d28e3bc9d743e763d6ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b665074cd1e6fddc875c7d36b305f66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a7b665074cd1e6fddc875c7d36b305f66">calcFrequencyCompensation</a> ()</td></tr>
<tr class="separator:a7b665074cd1e6fddc875c7d36b305f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7937f29c227ad663eb153b01b11d307f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a7937f29c227ad663eb153b01b11d307f">quitFrequencyCompensationCalcs</a> ()</td></tr>
<tr class="separator:a7937f29c227ad663eb153b01b11d307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e441b2259ae96759bf300c1f2af4ab1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a2e441b2259ae96759bf300c1f2af4ab1">addChild</a> (unsigned parentID, unsigned newID)</td></tr>
<tr class="memdesc:a2e441b2259ae96759bf300c1f2af4ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue an addChild instruction.  <a href="#a2e441b2259ae96759bf300c1f2af4ab1">More...</a><br /></td></tr>
<tr class="separator:a2e441b2259ae96759bf300c1f2af4ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627983362b1b84ee5d3c72d7540d9a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a627983362b1b84ee5d3c72d7540d9a47">reset</a> ()</td></tr>
<tr class="memdesc:a627983362b1b84ee5d3c72d7540d9a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">QUEUED ACTION - clears the entire network back to a single root node - node 0.  <a href="#a627983362b1b84ee5d3c72d7540d9a47">More...</a><br /></td></tr>
<tr class="separator:a627983362b1b84ee5d3c72d7540d9a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a425173fed2f3f30c1fa5c6e680764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#aa2a425173fed2f3f30c1fa5c6e680764">reset</a> (unsigned nodeID, double x1, double x2, double v1, double v2)</td></tr>
<tr class="separator:aa2a425173fed2f3f30c1fa5c6e680764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716d4e8f1dc446179c5424007995ab59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a716d4e8f1dc446179c5424007995ab59">setConnection</a> (unsigned NodeFrom, unsigned NodeTo, double weight)</td></tr>
<tr class="separator:a716d4e8f1dc446179c5424007995ab59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1335ac9672e6443135d78a8192b5aad5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a1335ac9672e6443135d78a8192b5aad5">setConnection</a> (unsigned NodeA, unsigned NodeB, double weightAtoB, double weightBtoA)</td></tr>
<tr class="separator:a1335ac9672e6443135d78a8192b5aad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22045d1c6d6c8bcf2b282c9c98e46f13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a22045d1c6d6c8bcf2b282c9c98e46f13">setConnectionPhaseOffset</a> (unsigned NodeFrom, unsigned NodeTo, double phase)</td></tr>
<tr class="memdesc:a22045d1c6d6c8bcf2b282c9c98e46f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">QUEUED ACTION - sets the phase offset of the connection (phase 0-1 for 0-2pi relative to parent's wavelength)  <a href="#a22045d1c6d6c8bcf2b282c9c98e46f13">More...</a><br /></td></tr>
<tr class="separator:a22045d1c6d6c8bcf2b282c9c98e46f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6d42576cafa238d020e62bdc9e2204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a5a6d42576cafa238d020e62bdc9e2204">removeConnection</a> (unsigned nodeFrom, unsigned NodeTo)</td></tr>
<tr class="memdesc:a5a6d42576cafa238d020e62bdc9e2204"><td class="mdescLeft">&#160;</td><td class="mdescRight">QUEUED ACTION - removes connection between indicated nodes if one exists.  <a href="#a5a6d42576cafa238d020e62bdc9e2204">More...</a><br /></td></tr>
<tr class="separator:a5a6d42576cafa238d020e62bdc9e2204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf37008845614f7b6a7ec0440141e06f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#abf37008845614f7b6a7ec0440141e06f">moveNode</a> (unsigned nodeID, unsigned newParentID, bool breakCurrParentChildConn, bool breakCurrChildParentConn)</td></tr>
<tr class="separator:abf37008845614f7b6a7ec0440141e06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475f866cfa6cf0e4249483a4ea2d5816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a475f866cfa6cf0e4249483a4ea2d5816">deleteNode</a> (unsigned nodeID)</td></tr>
<tr class="memdesc:a475f866cfa6cf0e4249483a4ea2d5816"><td class="mdescLeft">&#160;</td><td class="mdescRight">QUEUED ACTION -deletes the node, removes any connections to/from it.  <a href="#a475f866cfa6cf0e4249483a4ea2d5816">More...</a><br /></td></tr>
<tr class="separator:a475f866cfa6cf0e4249483a4ea2d5816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b932496b53001762dd0224eced6bd09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a1b932496b53001762dd0224eced6bd09">setFreqCompensation</a> (double compensation)</td></tr>
<tr class="separator:a1b932496b53001762dd0224eced6bd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a2a27ba2ad7f8ea7a4121326ac8a21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a22a2a27ba2ad7f8ea7a4121326ac8a21">setParam_t2Overt1</a> (double val)</td></tr>
<tr class="separator:a22a2a27ba2ad7f8ea7a4121326ac8a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad210d56ae83d896c39e72d93a6263035"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#ad210d56ae83d896c39e72d93a6263035">setParam_c</a> (double val)</td></tr>
<tr class="memdesc:ad210d56ae83d896c39e72d93a6263035"><td class="mdescLeft">&#160;</td><td class="mdescRight">QUEUED ACTION - sets the matsuoka's oscillator parameter C (tonic input: mainly controls amplitude)  <a href="#ad210d56ae83d896c39e72d93a6263035">More...</a><br /></td></tr>
<tr class="separator:ad210d56ae83d896c39e72d93a6263035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa568d548269415a9104a74eaec19d958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#aa568d548269415a9104a74eaec19d958">setParam_b</a> (double val)</td></tr>
<tr class="memdesc:aa568d548269415a9104a74eaec19d958"><td class="mdescLeft">&#160;</td><td class="mdescRight">QUEUED ACTION - sets the matsuoka's oscillator parameter b (adaptation to signal - mainly controls waveshape)  <a href="#aa568d548269415a9104a74eaec19d958">More...</a><br /></td></tr>
<tr class="separator:aa568d548269415a9104a74eaec19d958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4ab083a57717c7dba5d75ff3d1987a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#aba4ab083a57717c7dba5d75ff3d1987a">setParam_g</a> (double val)</td></tr>
<tr class="memdesc:aba4ab083a57717c7dba5d75ff3d1987a"><td class="mdescLeft">&#160;</td><td class="mdescRight">QUEUED ACTION - sets the matsuoka's oscillator parameter g (adaptation between neurons: mainly controls waveshape)  <a href="#aba4ab083a57717c7dba5d75ff3d1987a">More...</a><br /></td></tr>
<tr class="separator:aba4ab083a57717c7dba5d75ff3d1987a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd76608c9b7fb30bf9e0ed2ecd1ba40a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#acd76608c9b7fb30bf9e0ed2ecd1ba40a">setNodeFrequency</a> (unsigned nodeID, double freq, bool inherit)</td></tr>
<tr class="separator:acd76608c9b7fb30bf9e0ed2ecd1ba40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304bbae799a46734b1db0ac679f032e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a304bbae799a46734b1db0ac679f032e4">setNodeFrequencyMultiple</a> (unsigned nodeID, double multipleOfParent, bool inherit)</td></tr>
<tr class="separator:a304bbae799a46734b1db0ac679f032e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858deaa3246c884cc0693b494e398849"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a858deaa3246c884cc0693b494e398849">setNodePhaseOffset</a> (unsigned nodeID, double phase)</td></tr>
<tr class="separator:a858deaa3246c884cc0693b494e398849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e564e80779a3cd89cb3d4347920ba7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a4e564e80779a3cd89cb3d4347920ba7d">setNodeSelfNoise</a> (unsigned nodeID, double amount)</td></tr>
<tr class="memdesc:a4e564e80779a3cd89cb3d4347920ba7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">QUEUED ACTION -sets the amplitude of white noise going into the node.  <a href="#a4e564e80779a3cd89cb3d4347920ba7d">More...</a><br /></td></tr>
<tr class="separator:a4e564e80779a3cd89cb3d4347920ba7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa037d1bcb48e395ef6e789feab20b144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#aa037d1bcb48e395ef6e789feab20b144">setNodeSynchMode</a> (unsigned nodeID, <a class="el" href="classMatsuNode.html#a725e228db39b8842f851ddf88f640bed">synchMode</a> mode)</td></tr>
<tr class="separator:aa037d1bcb48e395ef6e789feab20b144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb38eaa5de05677243c5c7cd809af4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a8eb38eaa5de05677243c5c7cd809af4d">setNodeExternalInput</a> (unsigned nodeID, double weight, double <a class="el" href="classMatsuokaEngine.html#a811a5449f07004a2eb6b34e8c9bd862f">input</a>)</td></tr>
<tr class="separator:a8eb38eaa5de05677243c5c7cd809af4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc55b8350937748e0c0187a08130ca31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#afc55b8350937748e0c0187a08130ca31">resetNodeChangeFlag_Params</a> (unsigned nodeID)</td></tr>
<tr class="separator:afc55b8350937748e0c0187a08130ca31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fd8a9446e6bea6986d8de5c5c7bfd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a19fd8a9446e6bea6986d8de5c5c7bfd1">resetNodeChangeFlag_Inputs</a> (unsigned nodeID)</td></tr>
<tr class="separator:a19fd8a9446e6bea6986d8de5c5c7bfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb46c52bb2a430616aea63732aba7e32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#aeb46c52bb2a430616aea63732aba7e32">setNodeQuantiser_Grid</a> (unsigned nodeID, <a class="el" href="classQuantisedEventQueue.html#ae186d50bd503038452edbbdd0c7c259e">gridType</a> grid)</td></tr>
<tr class="memdesc:aeb46c52bb2a430616aea63732aba7e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the grid type for the quantiser for the node  <a href="#aeb46c52bb2a430616aea63732aba7e32">More...</a><br /></td></tr>
<tr class="separator:aeb46c52bb2a430616aea63732aba7e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1220a5a72f9bf35a9e6cd5a4f999f7e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a1220a5a72f9bf35a9e6cd5a4f999f7e5">setNodeQuantiser_Multiple</a> (unsigned nodeID, float mult)</td></tr>
<tr class="memdesc:a1220a5a72f9bf35a9e6cd5a4f999f7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the multiplier for grid coarseness (defines resolution of grid / no of valid positions on grid)  <a href="#a1220a5a72f9bf35a9e6cd5a4f999f7e5">More...</a><br /></td></tr>
<tr class="separator:a1220a5a72f9bf35a9e6cd5a4f999f7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12aafa189a6c9302937a00de6d291d42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a12aafa189a6c9302937a00de6d291d42">setNodeQuantiser_Offset</a> (unsigned nodeID, float off)</td></tr>
<tr class="memdesc:a12aafa189a6c9302937a00de6d291d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the offset of the grid - shifts the grid by this many base units  <a href="#a12aafa189a6c9302937a00de6d291d42">More...</a><br /></td></tr>
<tr class="separator:a12aafa189a6c9302937a00de6d291d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce59f3e8b45ab4c0ca804b17d8eb749"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQuantisedEventQueue.html#ae186d50bd503038452edbbdd0c7c259e">gridType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#adce59f3e8b45ab4c0ca804b17d8eb749">getNodeQuantiser_Grid</a> (unsigned nodeID)</td></tr>
<tr class="memdesc:adce59f3e8b45ab4c0ca804b17d8eb749"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the grid type of the quantiser for the node  <a href="#adce59f3e8b45ab4c0ca804b17d8eb749">More...</a><br /></td></tr>
<tr class="separator:adce59f3e8b45ab4c0ca804b17d8eb749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0b1a452f3d9252d460177779b2d681"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a1d0b1a452f3d9252d460177779b2d681">getNodeQuantiser_Multiple</a> (unsigned nodeID)</td></tr>
<tr class="memdesc:a1d0b1a452f3d9252d460177779b2d681"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the multiplier for grid coarseness (defines resolution of grid / no of valid positions on grid)  <a href="#a1d0b1a452f3d9252d460177779b2d681">More...</a><br /></td></tr>
<tr class="separator:a1d0b1a452f3d9252d460177779b2d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ab0eeb8a7d0b7f3a478ba41735cb8d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a05ab0eeb8a7d0b7f3a478ba41735cb8d">getNodeQuantiser_Offset</a> (unsigned nodeID)</td></tr>
<tr class="memdesc:a05ab0eeb8a7d0b7f3a478ba41735cb8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the offset of the grid (the number of base units the grid is shifted by)  <a href="#a05ab0eeb8a7d0b7f3a478ba41735cb8d">More...</a><br /></td></tr>
<tr class="separator:a05ab0eeb8a7d0b7f3a478ba41735cb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7edec268c651be3a45061cf9e90c123"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#af7edec268c651be3a45061cf9e90c123">getNodeQuantiser_BarDivision</a> (unsigned nodeID)</td></tr>
<tr class="separator:af7edec268c651be3a45061cf9e90c123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9057153267968489cd83ca31a1fbd985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a9057153267968489cd83ca31a1fbd985">setQuantiseAmount</a> (float amount)</td></tr>
<tr class="separator:a9057153267968489cd83ca31a1fbd985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae053fd0bdd438fa8a7f4cbd151122f89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#ae053fd0bdd438fa8a7f4cbd151122f89">setQuantiseAmount</a> (unsigned node, float amount)</td></tr>
<tr class="separator:ae053fd0bdd438fa8a7f4cbd151122f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf73c32f2c81d4895e98e1a8fe31cea1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#aaf73c32f2c81d4895e98e1a8fe31cea1">getQuantiseAmount</a> ()</td></tr>
<tr class="memdesc:aaf73c32f2c81d4895e98e1a8fe31cea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the strength of quantisation effect (0=no quantisation 1= strict quantisation)  <a href="#aaf73c32f2c81d4895e98e1a8fe31cea1">More...</a><br /></td></tr>
<tr class="separator:aaf73c32f2c81d4895e98e1a8fe31cea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8150c0efacb8f3d5ec2c3fb5731dfc97"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a8150c0efacb8f3d5ec2c3fb5731dfc97">getQuantiseAmount</a> (unsigned node)</td></tr>
<tr class="separator:a8150c0efacb8f3d5ec2c3fb5731dfc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ee17f0e948af6fcccdaeefa2c4e246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a23ee17f0e948af6fcccdaeefa2c4e246">setSampleRate</a> (unsigned sampleRate)</td></tr>
<tr class="separator:a23ee17f0e948af6fcccdaeefa2c4e246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf65a238e682b78fee81cd13b49174d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a3bf65a238e682b78fee81cd13b49174d">clear</a> ()</td></tr>
<tr class="memdesc:a3bf65a238e682b78fee81cd13b49174d"><td class="mdescLeft">&#160;</td><td class="mdescRight">clears the network back to single root node (node 0), resets all values to defaults  <a href="#a3bf65a238e682b78fee81cd13b49174d">More...</a><br /></td></tr>
<tr class="separator:a3bf65a238e682b78fee81cd13b49174d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd6ef89f68c1aa654229a07e0160f2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#affd6ef89f68c1aa654229a07e0160f2e">doQueuedActions</a> ()</td></tr>
<tr class="separator:affd6ef89f68c1aa654229a07e0160f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa099b8d5f49430d0fc84c16e0f4e67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#acaa099b8d5f49430d0fc84c16e0f4e67">setEventCallback</a> (Callback cb)</td></tr>
<tr class="separator:acaa099b8d5f49430d0fc84c16e0f4e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca77a2464c5852a0dbb9eed2d191ecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#afca77a2464c5852a0dbb9eed2d191ecb">setShutdown</a> (bool shutdown)</td></tr>
<tr class="memdesc:afca77a2464c5852a0dbb9eed2d191ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">tells the engine to shutdown  <a href="#afca77a2464c5852a0dbb9eed2d191ecb">More...</a><br /></td></tr>
<tr class="separator:afca77a2464c5852a0dbb9eed2d191ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929ade3a9ce6497e47183190255cbfae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a929ade3a9ce6497e47183190255cbfae">setPause</a> (bool pause)</td></tr>
<tr class="memdesc:a929ade3a9ce6497e47183190255cbfae"><td class="mdescLeft">&#160;</td><td class="mdescRight">(un/)pauses the engine (<a class="el" href="classMatsuokaEngine.html#a4fa468dc0814f1ad92594f7a4d5abd00" title="calculate one step of network calculations, and populate the event queue, ">step()</a> will have no effect while paused  <a href="#a929ade3a9ce6497e47183190255cbfae">More...</a><br /></td></tr>
<tr class="separator:a929ade3a9ce6497e47183190255cbfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7bb7f68eb7338a6c34eef10d421f68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a5d7bb7f68eb7338a6c34eef10d421f68">isShuttingDown</a> ()</td></tr>
<tr class="memdesc:a5d7bb7f68eb7338a6c34eef10d421f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">reports true if the system is in the process of shutting down  <a href="#a5d7bb7f68eb7338a6c34eef10d421f68">More...</a><br /></td></tr>
<tr class="separator:a5d7bb7f68eb7338a6c34eef10d421f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6e6f86762e4541854b4262eb217f7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a1b6e6f86762e4541854b4262eb217f7e">isIdle</a> ()</td></tr>
<tr class="memdesc:a1b6e6f86762e4541854b4262eb217f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">reports true if not currently calculating a step  <a href="#a1b6e6f86762e4541854b4262eb217f7e">More...</a><br /></td></tr>
<tr class="separator:a1b6e6f86762e4541854b4262eb217f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40114e7866da03ae1b7f37bcbde09876"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a40114e7866da03ae1b7f37bcbde09876">getEngineStepCounter</a> ()</td></tr>
<tr class="separator:a40114e7866da03ae1b7f37bcbde09876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738106afa4c313de36150a9687700193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a738106afa4c313de36150a9687700193">setDriven</a> (<a class="el" href="classMatsuokaEngine.html#ad8f471b2f1ca479174d5514b9a3597ec">externalSync</a> driven)</td></tr>
<tr class="separator:a738106afa4c313de36150a9687700193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b0d367297310a788461e3610e80623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a08b0d367297310a788461e3610e80623">setDrivingInput</a> (float val)</td></tr>
<tr class="separator:a08b0d367297310a788461e3610e80623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecbc93a17a602d8358c189363397575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatsuokaEngine.html#a9ecbc93a17a602d8358c189363397575">zeroSync</a> (unsigned nodeID)</td></tr>
<tr class="memdesc:a9ecbc93a17a602d8358c189363397575"><td class="mdescLeft">&#160;</td><td class="mdescRight">if SetDriven has been called, with value other than "none", this  <a href="#a9ecbc93a17a602d8358c189363397575">More...</a><br /></td></tr>
<tr class="separator:a9ecbc93a17a602d8358c189363397575"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Engine: Main interface for controlling and calculating the <a class="el" href="classCPG.html" title="Engine: Matsuoka Oscillator Central Pattern Generator Template Class. ">CPG</a> network. </p>
<p>Threadsafe - <a class="el" href="classMatsuokaEngine.html#a4fa468dc0814f1ad92594f7a4d5abd00" title="calculate one step of network calculations, and populate the event queue, ">step()</a>, <a class="el" href="classMatsuokaEngine.html#a70444163eee59d0df5b282bb8696f5a1" title="Returns vector of queued events and clears the event queue. ">getEvents()</a> etc. can be run in the signal-rate thread, while controlling the system using the other functions from another control thread (e.g. gui / etc.). To support this, some functions are not immediately actioned, but queued for actioning by the signal thread These queued functions are commented QUEUED ACTION All actions in the queue are executed when <a class="el" href="classMatsuokaEngine.html#affd6ef89f68c1aa654229a07e0160f2e">doQueuedActions()</a> is called (e.g. once per vector before doing signal calcs).</p>
<p>The two main outputs from the network are the signals of the nodes, and "events" Events are triggers - generated either by e.g positive zero crossing of the signal These events typically happen once per cycle and can be used for e.g. note triggers Events may be quantised to a timing-grid </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaf41ce5bf63099a1d864e4eb91527cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf41ce5bf63099a1d864e4eb91527cb5">&#9670;&nbsp;</a></span>gridType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classQuantisedEventQueue.html#ae186d50bd503038452edbbdd0c7c259e">MatsuokaEngine::gridType</a> =  <a class="el" href="classQuantisedEventQueue.html#ae186d50bd503038452edbbdd0c7c259e">QuantisedEventQueue::gridType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a811a5449f07004a2eb6b34e8c9bd862f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811a5449f07004a2eb6b34e8c9bd862f">&#9670;&nbsp;</a></span>input</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatsuokaEngine.html#a811a5449f07004a2eb6b34e8c9bd862f">MatsuokaEngine::input</a> =  <a class="el" href="structCPG_1_1input.html">CPG::input</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09035e4918ce82c9378821c88375f843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09035e4918ce82c9378821c88375f843">&#9670;&nbsp;</a></span>outputEvent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatsuokaEngine.html#a09035e4918ce82c9378821c88375f843">MatsuokaEngine::outputEvent</a> =  <a class="el" href="structQuantisedEventQueue_1_1outputEvent.html">QuantisedEventQueue::outputEvent</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbf2fcb6ddd3b8edc414753248b95fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf2fcb6ddd3b8edc414753248b95fc2">&#9670;&nbsp;</a></span>synchMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classMatsuNode.html#a725e228db39b8842f851ddf88f640bed">MatsuokaEngine::synchMode</a> =  <a class="el" href="classMatsuNode.html#a725e228db39b8842f851ddf88f640bed">MatsuNode::synchMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ad8f471b2f1ca479174d5514b9a3597ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f471b2f1ca479174d5514b9a3597ec">&#9670;&nbsp;</a></span>externalSync</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMatsuokaEngine.html#ad8f471b2f1ca479174d5514b9a3597ec">MatsuokaEngine::externalSync</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad8f471b2f1ca479174d5514b9a3597eca4c1d8f9abc3142b344a24624ea7c0a96"></a>none&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad8f471b2f1ca479174d5514b9a3597ecaf17848b3aa2effcdfd4576b7723ffc7b"></a>driving&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad8f471b2f1ca479174d5514b9a3597eca66dfc95cb0e1248f30385a100203920c"></a>reseting&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a25f70ceddea44651433ea8547b332ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f70ceddea44651433ea8547b332ecf">&#9670;&nbsp;</a></span>MatsuokaEngine() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatsuokaEngine::MatsuokaEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d26cc1bf5144ea89611377701716fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d26cc1bf5144ea89611377701716fea">&#9670;&nbsp;</a></span>MatsuokaEngine() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatsuokaEngine::MatsuokaEngine </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sampleRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eventOnRise</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eventOnFall</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fireOnPeak</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sample rate in Hz eventOnRise - generate 1 event per cycle when signal is rising eventOnFall - generate 1 event per cycle when signal is falling fireOnPeak - event is generated at signal peak (and/or trough) rather than zero crossing Events can thus be generated 0 1 or 2 times per cycle, at rising and/or falling zero crossings, or at first signal peak and/or trough. </p>

</div>
</div>
<a id="ab0c8d7fd6eb27c8a8dae7e5fa3742ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c8d7fd6eb27c8a8dae7e5fa3742ff9">&#9670;&nbsp;</a></span>MatsuokaEngine() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatsuokaEngine::MatsuokaEngine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatsuokaEngine.html">MatsuokaEngine</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2e441b2259ae96759bf300c1f2af4ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e441b2259ae96759bf300c1f2af4ab1">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MatsuokaEngine::addChild </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>parentID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>newID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue an addChild instruction. </p>
<p>QUEUED ACTION - adds a node to the network, with an incoming signal from the indicated node, the node is treated as "child" of node parentID when setting frequencies The node is assigned the requested id (so you need to make sure that ID is not in use). </p>

</div>
</div>
<a id="a7b665074cd1e6fddc875c7d36b305f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b665074cd1e6fddc875c7d36b305f66">&#9670;&nbsp;</a></span>calcFrequencyCompensation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::calcFrequencyCompensation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Avoid using. Superceded by calibrate. Will probably deprecate. starts frequency compensation calculations to set the error correction </p>

</div>
</div>
<a id="a68d6295dfa0d28e3bc9d743e763d6ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d6295dfa0d28e3bc9d743e763d6ee9">&#9670;&nbsp;</a></span>calibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::calibrate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>runs a calibration routine which sets a frequency error correction value for the current equation values. Should be run while engine is paused / not <a class="el" href="classMatsuokaEngine.html#a4fa468dc0814f1ad92594f7a4d5abd00" title="calculate one step of network calculations, and populate the event queue, ">step()</a>-ing This ensures that when a node's frequency is set to 1hz, it is actually 1hz. this needs to be run once at startup. AFter that, it need only be run after equation parameters other than t1 and t2 are changed. </p>

</div>
</div>
<a id="a3bf65a238e682b78fee81cd13b49174d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf65a238e682b78fee81cd13b49174d">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clears the network back to single root node (node 0), resets all values to defaults </p>

</div>
</div>
<a id="a475f866cfa6cf0e4249483a4ea2d5816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475f866cfa6cf0e4249483a4ea2d5816">&#9670;&nbsp;</a></span>deleteNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::deleteNode </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QUEUED ACTION -deletes the node, removes any connections to/from it. </p>

</div>
</div>
<a id="affd6ef89f68c1aa654229a07e0160f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd6ef89f68c1aa654229a07e0160f2e">&#9670;&nbsp;</a></span>doQueuedActions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::doQueuedActions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enacts the requests of methods which are commented QUEUED ACTION e.g. applies any queued requests to add nodes, change frequencies, etc. should be called e.g. once per signal vector, before doing the network calculations. </p>

</div>
</div>
<a id="a40114e7866da03ae1b7f37bcbde09876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40114e7866da03ae1b7f37bcbde09876">&#9670;&nbsp;</a></span>getEngineStepCounter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t MatsuokaEngine::getEngineStepCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The step counter begins at zero on initialisation and increments by one each time <a class="el" href="classMatsuokaEngine.html#a4fa468dc0814f1ad92594f7a4d5abd00" title="calculate one step of network calculations, and populate the event queue, ">step()</a> is called. this reports the current value of the step counter </p>

</div>
</div>
<a id="a70444163eee59d0df5b282bb8696f5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70444163eee59d0df5b282bb8696f5a1">&#9670;&nbsp;</a></span>getEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classMatsuokaEngine.html#a09035e4918ce82c9378821c88375f843">MatsuokaEngine::outputEvent</a> &gt; MatsuokaEngine::getEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns vector of queued events and clears the event queue. </p>

</div>
</div>
<a id="a87b0d0b8fe0447fba1fe7456dbea4e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b0d0b8fe0447fba1fe7456dbea4e11">&#9670;&nbsp;</a></span>getFrequencyCompensation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MatsuokaEngine::getFrequencyCompensation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the frequency error correction value currently set for the network See calcFrequencyCompensation </p>

</div>
</div>
<a id="a7b8067a4f72a8376635ce2d61bece1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8067a4f72a8376635ce2d61bece1f2">&#9670;&nbsp;</a></span>getInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classMatsuokaEngine.html#a811a5449f07004a2eb6b34e8c9bd862f">input</a> &gt; MatsuokaEngine::getInputs </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return details of the inputs from other nodes, into the requested node </p>

</div>
</div>
<a id="ae2d2de39e55b20e6c579039eb6081246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d2de39e55b20e6c579039eb6081246">&#9670;&nbsp;</a></span>getNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatsuNode.html">MatsuNode</a> &amp; MatsuokaEngine::getNode </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns const reference to the requested node </p>

</div>
</div>
<a id="a8eb45ab4f1c523f979b3d44dd2c5e508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb45ab4f1c523f979b3d44dd2c5e508">&#9670;&nbsp;</a></span>getNodeChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned &gt; MatsuokaEngine::getNodeChildren </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns list of IDs of children of the requested node </p>

</div>
</div>
<a id="a88d27453816ff152b17b6e744979e994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d27453816ff152b17b6e744979e994">&#9670;&nbsp;</a></span>getNodeFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MatsuokaEngine::getNodeFrequency </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the frequency of the requested node </p>

</div>
</div>
<a id="a0f7aa58c722f9bce30724d4a62c72374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7aa58c722f9bce30724d4a62c72374">&#9670;&nbsp;</a></span>getNodeInputPhase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MatsuokaEngine::getNodeInputPhase </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>inputID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the phase offset applied to the signal connection between nodes inputID and nodeID (0-1) </p>

</div>
</div>
<a id="ae8f070a75e9005f6cc1f3c2b33c4baf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f070a75e9005f6cc1f3c2b33c4baf5">&#9670;&nbsp;</a></span>getNodeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned &gt; MatsuokaEngine::getNodeList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>list ids of all nodes in the network </p>

</div>
</div>
<a id="a72ba599f12e55273f7298a70e7f0eff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ba599f12e55273f7298a70e7f0eff7">&#9670;&nbsp;</a></span>getNodeOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MatsuokaEngine::getNodeOutput </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sampleOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>matchQuantiser</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the current oscillator output signal value of the requested node sampleOffset: delay in samples applied to the output matchQuantiser: if using the quantiser, True will apply an additional delay to synchronise the signal output with the quantiser events </p>

</div>
</div>
<a id="a5d808db0af62f65826f0fcbc47625205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d808db0af62f65826f0fcbc47625205">&#9670;&nbsp;</a></span>getNodeParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MatsuokaEngine::getNodeParent </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the parent id of the requested node </p>

</div>
</div>
<a id="a201de701852d315d3eac20c749b19752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201de701852d315d3eac20c749b19752">&#9670;&nbsp;</a></span>getNodePhaseOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MatsuokaEngine::getNodePhaseOffset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the phase offset applied to the output of the requested node (0-1) phase offset is set by user - effectively a delay between 0 and 1.0 times the node 0s signal wavelength. Useful for rhythmic offsetting. </p>

</div>
</div>
<a id="af7edec268c651be3a45061cf9e90c123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7edec268c651be3a45061cf9e90c123">&#9670;&nbsp;</a></span>getNodeQuantiser_BarDivision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MatsuokaEngine::getNodeQuantiser_BarDivision </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the no of base units per "bar" of the grid (a "bar" is 1 cycle of node 0) set by setNodeQuantiser_Multiple </p>

</div>
</div>
<a id="adce59f3e8b45ab4c0ca804b17d8eb749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce59f3e8b45ab4c0ca804b17d8eb749">&#9670;&nbsp;</a></span>getNodeQuantiser_Grid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQuantisedEventQueue.html#ae186d50bd503038452edbbdd0c7c259e">MatsuokaEngine::gridType</a> MatsuokaEngine::getNodeQuantiser_Grid </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the grid type of the quantiser for the node </p>

</div>
</div>
<a id="a1d0b1a452f3d9252d460177779b2d681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0b1a452f3d9252d460177779b2d681">&#9670;&nbsp;</a></span>getNodeQuantiser_Multiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MatsuokaEngine::getNodeQuantiser_Multiple </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the multiplier for grid coarseness (defines resolution of grid / no of valid positions on grid) </p>

</div>
</div>
<a id="a05ab0eeb8a7d0b7f3a478ba41735cb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ab0eeb8a7d0b7f3a478ba41735cb8d">&#9670;&nbsp;</a></span>getNodeQuantiser_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MatsuokaEngine::getNodeQuantiser_Offset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the offset of the grid (the number of base units the grid is shifted by) </p>

</div>
</div>
<a id="a6857e20e39f058a4145fdc4493df6583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6857e20e39f058a4145fdc4493df6583">&#9670;&nbsp;</a></span>getNodeSelfNoise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MatsuokaEngine::getNodeSelfNoise </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the amplitude of the noise input to the requested node </p>

</div>
</div>
<a id="aaf73c32f2c81d4895e98e1a8fe31cea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf73c32f2c81d4895e98e1a8fe31cea1">&#9670;&nbsp;</a></span>getQuantiseAmount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MatsuokaEngine::getQuantiseAmount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets the strength of quantisation effect (0=no quantisation 1= strict quantisation) </p>

</div>
</div>
<a id="a8150c0efacb8f3d5ec2c3fb5731dfc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8150c0efacb8f3d5ec2c3fb5731dfc97">&#9670;&nbsp;</a></span>getQuantiseAmount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MatsuokaEngine::getQuantiseAmount </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2757e406e811cbe2e28f8b661cf29472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2757e406e811cbe2e28f8b661cf29472">&#9670;&nbsp;</a></span>getSampleRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MatsuokaEngine::getSampleRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns sample rate of the system </p>

</div>
</div>
<a id="a1b6e6f86762e4541854b4262eb217f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6e6f86762e4541854b4262eb217f7e">&#9670;&nbsp;</a></span>isIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MatsuokaEngine::isIdle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reports true if not currently calculating a step </p>

</div>
</div>
<a id="a5d7bb7f68eb7338a6c34eef10d421f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7bb7f68eb7338a6c34eef10d421f68">&#9670;&nbsp;</a></span>isShuttingDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MatsuokaEngine::isShuttingDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reports true if the system is in the process of shutting down </p>

</div>
</div>
<a id="ae2ad27d38196e2217bdb0b5da35fd095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ad27d38196e2217bdb0b5da35fd095">&#9670;&nbsp;</a></span>loadConnectionWeightCurve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MatsuokaEngine::loadConnectionWeightCurve </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>expects a table of values: used to scale connection weights between nodes Each line should hold two floats, one for frequency ratio, the other for the weight multiplier. See <a class="el" href="classMatsuokaEngine.html#adb864bf26563682f94ba2e131fb8b793">setConnectionWeightScaling()</a> and <a class="el" href="ScalingCurve_8h.html">ScalingCurve.h</a> </p>

</div>
</div>
<a id="ad05eb51876bee90334426757a981139b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05eb51876bee90334426757a981139b">&#9670;&nbsp;</a></span>loadConnectionWeightCurve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MatsuokaEngine::loadConnectionWeightCurve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>expects a table of values: used to scale connection weights between nodes Each line should hold two floats, one for frequency ratio, the other for the weight multiplier. See <a class="el" href="classMatsuokaEngine.html#adb864bf26563682f94ba2e131fb8b793">setConnectionWeightScaling()</a> and <a class="el" href="ScalingCurve_8h.html">ScalingCurve.h</a> </p>

</div>
</div>
<a id="abf37008845614f7b6a7ec0440141e06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf37008845614f7b6a7ec0440141e06f">&#9670;&nbsp;</a></span>moveNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::moveNode </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>newParentID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>breakCurrParentChildConn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>breakCurrChildParentConn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QUEUED ACTION - moves the node in the network topology to the indicated parent optional parameters to break current parent and child connections as well as create new parent connection I can't remember why I thought we needed this. Has not been used much. Caution. </p>

</div>
</div>
<a id="aac87afef0c7c99601fa77e2be27b2b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac87afef0c7c99601fa77e2be27b2b74">&#9670;&nbsp;</a></span>nodeExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MatsuokaEngine::nodeExists </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the nodeID exists in the network </p>

</div>
</div>
<a id="a7937f29c227ad663eb153b01b11d307f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7937f29c227ad663eb153b01b11d307f">&#9670;&nbsp;</a></span>quitFrequencyCompensationCalcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::quitFrequencyCompensationCalcs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>quits frequency compensation calculations. If called during <a class="el" href="classMatsuokaEngine.html#a68d6295dfa0d28e3bc9d743e763d6ee9">calibrate()</a> will ruin the results avoid using. was used alongside calcFrequencyCompensation, now superceded by calibrate </p>

</div>
</div>
<a id="a5a6d42576cafa238d020e62bdc9e2204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6d42576cafa238d020e62bdc9e2204">&#9670;&nbsp;</a></span>removeConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::removeConnection </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>NodeTo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QUEUED ACTION - removes connection between indicated nodes if one exists. </p>

</div>
</div>
<a id="a627983362b1b84ee5d3c72d7540d9a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627983362b1b84ee5d3c72d7540d9a47">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QUEUED ACTION - clears the entire network back to a single root node - node 0. </p>

</div>
</div>
<a id="aa2a425173fed2f3f30c1fa5c6e680764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a425173fed2f3f30c1fa5c6e680764">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::reset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QUEUED ACTION - resets the internal state of the indicated node to the requested values Very badly named given the presense of <a class="el" href="classMatsuokaEngine.html#a627983362b1b84ee5d3c72d7540d9a47" title="QUEUED ACTION - clears the entire network back to a single root node - node 0. ">reset()</a>. Apologies! I didn't sleep very much towards the end of my Msc. </p>

</div>
</div>
<a id="a19fd8a9446e6bea6986d8de5c5c7bfd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fd8a9446e6bea6986d8de5c5c7bfd1">&#9670;&nbsp;</a></span>resetNodeChangeFlag_Inputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::resetNodeChangeFlag_Inputs </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>resets the flag that indicates that node inputs have been changed useful for GUI development </p>

</div>
</div>
<a id="afc55b8350937748e0c0187a08130ca31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc55b8350937748e0c0187a08130ca31">&#9670;&nbsp;</a></span>resetNodeChangeFlag_Params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::resetNodeChangeFlag_Params </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>resets the flag that indicates that node parameters have been changed useful for GUI development </p>

</div>
</div>
<a id="a716d4e8f1dc446179c5424007995ab59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716d4e8f1dc446179c5424007995ab59">&#9670;&nbsp;</a></span>setConnection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setConnection </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>NodeFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>NodeTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QUEUED ACTION - sets the connection weight between indicated nodes. Adds the connection if one does not already exist </p>

</div>
</div>
<a id="a1335ac9672e6443135d78a8192b5aad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1335ac9672e6443135d78a8192b5aad5">&#9670;&nbsp;</a></span>setConnection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setConnection </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>NodeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>NodeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weightAtoB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weightBtoA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QUEUED ACTION - sets connection weight both ways between indicated nodes adds connections if they do not exist </p>

</div>
</div>
<a id="a22045d1c6d6c8bcf2b282c9c98e46f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22045d1c6d6c8bcf2b282c9c98e46f13">&#9670;&nbsp;</a></span>setConnectionPhaseOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setConnectionPhaseOffset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>NodeFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>NodeTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QUEUED ACTION - sets the phase offset of the connection (phase 0-1 for 0-2pi relative to parent's wavelength) </p>

</div>
</div>
<a id="adb864bf26563682f94ba2e131fb8b793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb864bf26563682f94ba2e131fb8b793">&#9670;&nbsp;</a></span>setConnectionWeightScaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setConnectionWeightScaling </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>turns on or off the contextual scaling of connection weights. This scales input weights based on the ratio of the source node's frequency to the destination node's frequency. Matsuoka's oscillator responds to incoming signals more or less strongly depending on the relationshpi between the incoming signal frequency and its own freq This contextual scaling counteracts this effect so that the oscillator behaves more consistently. So that e.g. a weight of 1.0 has a similar effect whether the incoming signal is 3 or 5 times the node's current oscillation frequency. Using this requires that you have set the appropriate curve for your equation parameters, using loadConnectionWeightCurve. These curves must be generated by simulation and there is currently no facility in the library to generate these curves (TODO). </p>

</div>
</div>
<a id="a738106afa4c313de36150a9687700193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738106afa4c313de36150a9687700193">&#9670;&nbsp;</a></span>setDriven()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setDriven </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatsuokaEngine.html#ad8f471b2f1ca479174d5514b9a3597ec">externalSync</a>&#160;</td>
          <td class="paramname"><em>driven</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set system to be driven by an external phasor this allows for synchronisation to e.g. sequencers. none: the system runs freely driven: the phasor input drives node 0 directly (signal feedback into node 0 has no effect). in this mode, node 0 is a wavetable oscillator whose wavetable is one cycle of the oscillator without input reseting: the phasor calculates as normal, but is reset to its state at positive zero crossing every time the phasor wraps in this mode signal feedback into node 0 has some limited effect, but the system re-synchronises to input at each bar. </p>

</div>
</div>
<a id="a08b0d367297310a788461e3610e80623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b0d367297310a788461e3610e80623">&#9670;&nbsp;</a></span>setDrivingInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setDrivingInput </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set value of external driving phasor (drives node0) needs to be called once per sample if the network is driven (see <a class="el" href="classMatsuokaEngine.html#a738106afa4c313de36150a9687700193">setDriven()</a>) </p>

</div>
</div>
<a id="acaa099b8d5f49430d0fc84c16e0f4e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa099b8d5f49430d0fc84c16e0f4e67">&#9670;&nbsp;</a></span>setEventCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setEventCallback </td>
          <td>(</td>
          <td class="paramtype">Callback&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sets a callback which will be called for each output event for details of output events see class constructor. calback should take an int (nodeID) and a float (amplitude peak at event) </p>

</div>
</div>
<a id="a1b932496b53001762dd0224eced6bd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b932496b53001762dd0224eced6bd09">&#9670;&nbsp;</a></span>setFreqCompensation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setFreqCompensation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>compensation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QUEUED ACTION -directly sets the frequency compensation which is used for the control of node frequency in most cases, just use <a class="el" href="classMatsuokaEngine.html#a68d6295dfa0d28e3bc9d743e763d6ee9">calibrate()</a> instead. </p>

</div>
</div>
<a id="a8eb38eaa5de05677243c5c7cd809af4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb38eaa5de05677243c5c7cd809af4d">&#9670;&nbsp;</a></span>setNodeExternalInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setNodeExternalInput </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QUEUED ACTION - set input of 1 sample of an external signal to a node Just 1 sample, so needs to be called every step. TODO: input-pointer version so you can set and forget. </p>

</div>
</div>
<a id="acd76608c9b7fb30bf9e0ed2ecd1ba40a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd76608c9b7fb30bf9e0ed2ecd1ba40a">&#9670;&nbsp;</a></span>setNodeFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setNodeFrequency </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inherit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QUEUED ACTION - sets frequency of the node If inherit=true it also changes child nodes' frequencies, proportionally (e.g. if you double the freq of this node, the freqs of the child nodes double too). (this function assumes that <a class="el" href="classMatsuokaEngine.html#a68d6295dfa0d28e3bc9d743e763d6ee9">calibrate()</a> has been run more recently than any of the setParam_ methods otherwise frequency will not be set accurately). </p>

</div>
</div>
<a id="a304bbae799a46734b1db0ac679f032e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304bbae799a46734b1db0ac679f032e4">&#9670;&nbsp;</a></span>setNodeFrequencyMultiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setNodeFrequencyMultiple </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>multipleOfParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inherit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QUEUED ACTION - sets frequency of the node as a multiple of its parent node's frequency <br />
If inherit=true it also changes child nodes' frequencies, proportionally (e.g. if you double the freq of this node, the freqs of the child nodes double too). (this function assumes that <a class="el" href="classMatsuokaEngine.html#a68d6295dfa0d28e3bc9d743e763d6ee9">calibrate()</a> has been run more recently than any of the setParam_ methods otherwise frequency will not be set accurately). </p>

</div>
</div>
<a id="a858deaa3246c884cc0693b494e398849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858deaa3246c884cc0693b494e398849">&#9670;&nbsp;</a></span>setNodePhaseOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setNodePhaseOffset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QUEUED ACTION - sets the phase offset of the node's output (0-1 as proportion of parent's wavelength) handled via delay </p>

</div>
</div>
<a id="aeb46c52bb2a430616aea63732aba7e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb46c52bb2a430616aea63732aba7e32">&#9670;&nbsp;</a></span>setNodeQuantiser_Grid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setNodeQuantiser_Grid </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQuantisedEventQueue.html#ae186d50bd503038452edbbdd0c7c259e">gridType</a>&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the grid type for the quantiser for the node </p>

</div>
</div>
<a id="a1220a5a72f9bf35a9e6cd5a4f999f7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1220a5a72f9bf35a9e6cd5a4f999f7e5">&#9670;&nbsp;</a></span>setNodeQuantiser_Multiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setNodeQuantiser_Multiple </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the multiplier for grid coarseness (defines resolution of grid / no of valid positions on grid) </p>

</div>
</div>
<a id="a12aafa189a6c9302937a00de6d291d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12aafa189a6c9302937a00de6d291d42">&#9670;&nbsp;</a></span>setNodeQuantiser_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setNodeQuantiser_Offset </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the offset of the grid - shifts the grid by this many base units </p>

</div>
</div>
<a id="a4e564e80779a3cd89cb3d4347920ba7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e564e80779a3cd89cb3d4347920ba7d">&#9670;&nbsp;</a></span>setNodeSelfNoise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setNodeSelfNoise </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QUEUED ACTION -sets the amplitude of white noise going into the node. </p>

</div>
</div>
<a id="aa037d1bcb48e395ef6e789feab20b144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa037d1bcb48e395ef6e789feab20b144">&#9670;&nbsp;</a></span>setNodeSynchMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setNodeSynchMode </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatsuNode.html#a725e228db39b8842f851ddf88f640bed">synchMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QUEUED ACTION -sets synchronisation mode for the node</p><ul>
<li>free (no synchronisation),</li>
<li>synchOnce - synchronise once (on next zero crossing of parent node, this node is also reset to zero crossing state)</li>
<li>synchLock - (synchronisation happens at <em>every</em> parent zero-crossing). I have not found synchLoc useful. synchOnce is useful e.g. when spawning a new node, </li>
</ul>

</div>
</div>
<a id="aa568d548269415a9104a74eaec19d958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa568d548269415a9104a74eaec19d958">&#9670;&nbsp;</a></span>setParam_b()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setParam_b </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QUEUED ACTION - sets the matsuoka's oscillator parameter b (adaptation to signal - mainly controls waveshape) </p>

</div>
</div>
<a id="ad210d56ae83d896c39e72d93a6263035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad210d56ae83d896c39e72d93a6263035">&#9670;&nbsp;</a></span>setParam_c()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setParam_c </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QUEUED ACTION - sets the matsuoka's oscillator parameter C (tonic input: mainly controls amplitude) </p>

</div>
</div>
<a id="aba4ab083a57717c7dba5d75ff3d1987a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4ab083a57717c7dba5d75ff3d1987a">&#9670;&nbsp;</a></span>setParam_g()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setParam_g </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QUEUED ACTION - sets the matsuoka's oscillator parameter g (adaptation between neurons: mainly controls waveshape) </p>

</div>
</div>
<a id="a22a2a27ba2ad7f8ea7a4121326ac8a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a2a27ba2ad7f8ea7a4121326ac8a21">&#9670;&nbsp;</a></span>setParam_t2Overt1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setParam_t2Overt1 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>QUEUED ACTION -sets the ratio between the matsuoka's oscillator parameters t2 and t1 - time parameters e.g if you set this to 4, and T1 is 1, then T2 will be 4 this ratio affects waveshape. The values for t2 and t1 are not set directly since they are set by setNodeFrequency. </p>

</div>
</div>
<a id="a929ade3a9ce6497e47183190255cbfae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929ade3a9ce6497e47183190255cbfae">&#9670;&nbsp;</a></span>setPause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setPause </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pause</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(un/)pauses the engine (<a class="el" href="classMatsuokaEngine.html#a4fa468dc0814f1ad92594f7a4d5abd00" title="calculate one step of network calculations, and populate the event queue, ">step()</a> will have no effect while paused </p>

</div>
</div>
<a id="a9057153267968489cd83ca31a1fbd985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9057153267968489cd83ca31a1fbd985">&#9670;&nbsp;</a></span>setQuantiseAmount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setQuantiseAmount </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>amount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sets the strength of quantisation effect (0=no quantisation 1= strict quantisation) 0 means notes are not affected by the quantiser 1 means notes are moved to the nearest quantiser grid position values in between nudge the note towards the nearest grid position, to a greater or lesser degree </p>

</div>
</div>
<a id="ae053fd0bdd438fa8a7f4cbd151122f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae053fd0bdd438fa8a7f4cbd151122f89">&#9670;&nbsp;</a></span>setQuantiseAmount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setQuantiseAmount </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23ee17f0e948af6fcccdaeefa2c4e246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ee17f0e948af6fcccdaeefa2c4e246">&#9670;&nbsp;</a></span>setSampleRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setSampleRate </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sampleRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sets the sample rate (expected no of calculations/outputs per second) - used in internal calculations (this value should match the number of times per second you call <a class="el" href="classMatsuokaEngine.html#a4fa468dc0814f1ad92594f7a4d5abd00" title="calculate one step of network calculations, and populate the event queue, ">step()</a> per second) </p>

</div>
</div>
<a id="afca77a2464c5852a0dbb9eed2d191ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca77a2464c5852a0dbb9eed2d191ecb">&#9670;&nbsp;</a></span>setShutdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setShutdown </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shutdown</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tells the engine to shutdown </p>

</div>
</div>
<a id="aa7254e0141ad5763ff6267a8430b30ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7254e0141ad5763ff6267a8430b30ab">&#9670;&nbsp;</a></span>setUnityConnectionWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::setUnityConnectionWeight </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>unity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales the inputs: sets the incoming value which should map to weight of 1 when setting connections. </p>

</div>
</div>
<a id="a4fa468dc0814f1ad92594f7a4d5abd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa468dc0814f1ad92594f7a4d5abd00">&#9670;&nbsp;</a></span>step() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::step </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate one step of network calculations, and populate the event queue, </p>

</div>
</div>
<a id="aedf2583d11befa98a8a9d74c700635d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf2583d11befa98a8a9d74c700635d6">&#9670;&nbsp;</a></span>step() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::step </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>do one calculation step for the indicated node, </p>

</div>
</div>
<a id="a12519e69a1b16fe9c07717ded5249cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12519e69a1b16fe9c07717ded5249cdf">&#9670;&nbsp;</a></span>stepBareBones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::stepBareBones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>no syncing, no quantiser, no freq Compensation Calcs etc., </p>

</div>
</div>
<a id="a9ecbc93a17a602d8358c189363397575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecbc93a17a602d8358c189363397575">&#9670;&nbsp;</a></span>zeroSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatsuokaEngine::zeroSync </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nodeID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if SetDriven has been called, with value other than "none", this </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>O:/Documents/Max 7/Packages/max_cpg/source/MatsuokaEngine_src/<a class="el" href="MatsuokaEngine_8h_source.html">MatsuokaEngine.h</a></li>
<li>O:/Documents/Max 7/Packages/max_cpg/source/MatsuokaEngine_src/<a class="el" href="MatsuokaEngine_8cpp.html">MatsuokaEngine.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
