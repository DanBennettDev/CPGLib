#pragma once


/*! \class MatsuokaEngine
*  \brief Main interface / top level class for most purposes. Create, manipulate and simulate a CPG network via this class.
*
*  Threadsafe - step(), getEvents() etc. can be run in the signal-rate thread, while controlling the system
*  using the other functions from another control thread (e.g. gui / etc.). 
*  To support this, some functions are not immediately actioned, but queued for actioning by the signal thread
*  These queued functions are commented QUEUED ACTION
*  All actions in the queue are executed when doQueuedActions() is called (e.g. once per vector before doing signal calcs). 
* 
*  The two main outputs from the network are the signals of the nodes, and "events"
*  Events are triggers - generated either by e.g positive zero crossing of the signal
*  These events typically happen once per cycle and can be used for e.g. note triggers 
*  Events may be quantised to a timing-grid
*  
*  
*
*/

//TODO:
//- method to generate weight scaling curve for arbitrary parameters
//- Rewrite quantiser to avoid allocation in the DSP thread 
//- invertable connections
//- Waveshaping options for connections to change node response(raise to power, and threshold)
//- Halt / Restart connection mode.

#include <mutex>
#include <vector>
#include <queue>
#include <functional>
#include <string>
#include "CPG.h"
#include "QuantisedEventQueue.h"



class MatsuokaEngine
{

typedef  std::function<void(int, float)> Callback;

public:

    // simplify usage in classes interacting with the engine
    using input = CPG::input;    
    using synchMode = MatsuNode::synchMode;
    using outputEvent = QuantisedEventQueue::outputEvent;
    using gridType = QuantisedEventQueue::gridType;

	enum externalSync {
		none, driving, reseting
	};

	/// \brief Constructor initialising with DEFAULTSAMPLERATE (see core.h). 
	/// This sets up the engine to generate a single event per cycle of each node, 
	/// occuring at the outputs positive zero crossing. Other configurations are possible using the 
	/// constructor overload(s)
    MatsuokaEngine();

	/// \brief Constructor determining sample rate and event output behaviour. 
	/// Events can thus be generated 0 1 or 2 times per cycle, at rising and/or falling zero crossings,
	/// or at first signal peak and/or trough.
    MatsuokaEngine(
					unsigned sampleRate, //!<  sample rate in Hz
                    bool eventOnRise = true, //!<  generate 1 event per cycle when signal is rising 
                    bool eventOnFall = false, //!<  eventOnFall - generate 1 event per cycle when signal is falling 
                    bool fireOnPeak = false //!<  fireOnPeak - event(s) are generated at signal peak (and/or trough) rather than zero crossing
					);
    MatsuokaEngine(const MatsuokaEngine& rhs);


    // METHODS
    /// calculate one step of network calculations, and populate the event queue,
    void step();

	/// no syncing, no quantiser, no freq Compensation Calcs etc.,
	void stepBareBones();

    /// do one calculation step for the indicated node, 
    void step(unsigned nodeID);

    /// list ids of all nodes in the network
    std::vector<unsigned> getNodeList() const;
    
    /// return details of the inputs from other nodes, into the requested node 
    std::vector<CPG::input> getInputs(unsigned nodeID) const;

    /// returns true if the nodeID exists in the network
    bool nodeExists(unsigned nodeID) const;

    /// returns const reference to the requested node
    const MatsuNode& getNode(unsigned nodeID) const;

    /// returns sample rate of the system
    unsigned getSampleRate() const;


    /// turns on or off the contextual scaling of connection weights. 
	/// This scales input weights based on the ratio of the source node's frequency
	/// to the destination node's frequency. 
    /// Matsuoka's oscillator responds to incoming signals more or less strongly 
	/// depending on the relationshpi between the incoming signal frequency and its own freq
	/// This contextual scaling counteracts this effect so that the oscillator behaves
	/// more consistently. So that e.g. a weight of 1.0 has a similar effect whether
	/// the incoming signal is 3 or 5 times the node's current oscillation frequency.
	/// Using this requires that you have set the appropriate curve for your equation parameters, 
	/// using loadConnectionWeightCurve. These curves must be generated by simulation
	/// and there is currently no facility in the library to generate these curves (TODO).
    void setConnectionWeightScaling(bool on);


    /// expects a table of values: used to scale connection weights between nodes
    /// Each line should hold two floats, one for frequency ratio, the other
    /// for the weight multiplier. See setConnectionWeightScaling() and ScalingCurve.h
    bool loadConnectionWeightCurve(std::string source);

	/// expects a table of values: used to scale connection weights between nodes
	/// Each line should hold two floats, one (x) for frequency ratio, the other (y) 
	/// for the weight multiplier. See setConnectionWeightScaling() and ScalingCurve.h
	bool loadConnectionWeightCurve(std::vector<float> x, std::vector<float> y);

    /// Scales the inputs: sets the incoming value which should map to weight of 1 when setting connections
    void setUnityConnectionWeight(float unity);

    //// Lists all node ids which are in use in the engine
    //std::vector<unsigned> listActiveNodeIDs() const;

    /// returns the frequency of the requested node
    double getNodeFrequency(unsigned nodeID) const;

    /// returns the parent id of the requested node
    unsigned getNodeParent(unsigned nodeID) const;

    /// returns list of IDs of children of the requested node
    std::vector<unsigned> getNodeChildren(unsigned nodeID) const;
    
    /// returns the current oscillator output signal value of the requested node
	/// sampleOffset: delay in samples applied to the output
	/// matchQuantiser: if using the quantiser, True will apply an additional 
	/// delay to synchronise the signal output with the quantiser events
	double getNodeOutput(unsigned nodeID, unsigned sampleOffset = 0 , bool matchQuantiser = false) const;

    /// returns the frequency error correction value currently set for the network
	/// See calcFrequencyCompensation
    double getFrequencyCompensation() const;

    /// returns the phase offset applied to the output of the requested node (0-1)
	/// phase offset is set by user - effectively a delay between 0 and 1.0 times the 
	/// node 0s signal wavelength. Useful for rhythmic offsetting.
    double getNodePhaseOffset(unsigned nodeID) const;

    /// returns the amplitude of the noise input to the requested node
    double getNodeSelfNoise(unsigned nodeID) const;

    /// returns the phase offset applied to the signal connection between nodes inputID and nodeID (0-1)
    double getNodeInputPhase(unsigned nodeID, unsigned inputID) const;


    /// Returns vector of queued events and clears the event queue.
    const std::vector<outputEvent> getEvents();

    /// runs a calibration routine which sets a frequency error correction value for
    /// the current equation values. Should be run while engine is paused / not step()-ing
	/// This ensures that when a node's frequency is set to 1hz, it is actually 1hz.
	/// this needs to be run once at startup. AFter that, it need only be run 
	/// after equation parameters other than t1 and t2 are changed. 
    void calibrate();

	/// Avoid using. Superceded by calibrate. Will probably deprecate.
    /// starts frequency compensation calculations to set the error correction 
    void calcFrequencyCompensation();

    /// quits frequency compensation calculations. If called during calibrate()
    /// will ruin the results
	/// avoid using. was used alongside calcFrequencyCompensation, now superceded by calibrate
    void quitFrequencyCompensationCalcs();


    // QUEUEING METHODS/////////////////////////////////////////////////////////////////////////////////////
	// These make requests for changes, which are queued, and only actioned when doQueuedActions() is called.

    /// QUEUED ACTION - adds a node to the network, with an incoming signal from the indicated node, 
	/// the node is treated as "child" of node parentID when setting frequencies
	/// The node is assigned the requested id (so you need to make sure that ID is not in use).
    unsigned addChild(unsigned parentID, unsigned newID);
   
    /// QUEUED ACTION - clears the entire network back to a single root node - node 0
    void reset();

    /// QUEUED ACTION - resets the internal state of the indicated node to the requested values
	/// Very badly named given the presense of reset(). Apologies! I didn't sleep very much
	/// towards the end of my Msc.
    void reset(unsigned nodeID, double x1, double x2, double v1, double v2);
    
    /// QUEUED ACTION - sets the connection weight between indicated nodes. 
    /// Adds the connection if one does not already exist
    void setConnection(unsigned NodeFrom, unsigned NodeTo, double weight);
    
    /// QUEUED ACTION - sets connection weight both ways between indicated nodes
    /// adds connections if they do not exist
    void setConnection(unsigned NodeA, unsigned NodeB, double weightAtoB,
        double weightBtoA);

    /// QUEUED ACTION - sets the phase offset of the connection (phase 0-1 for 0-2pi relative to parent's wavelength)
    void setConnectionPhaseOffset(unsigned NodeFrom, unsigned NodeTo, double phase);

    /// QUEUED ACTION - removes connection between indicated nodes if one exists
    void removeConnection(unsigned nodeFrom, unsigned NodeTo);
    
    /// QUEUED ACTION - moves the node in the network topology to the indicated parent
    /// optional parameters to break current parent and child connections as well as 
    /// create new parent connection
	/// I can't remember why I thought we needed this. Has not been used much. Caution. 
    void moveNode(unsigned nodeID, unsigned newParentID,
        bool breakCurrParentChildConn, bool breakCurrChildParentConn);
    
    /// QUEUED ACTION -deletes the node, removes any connections to/from it
    void deleteNode(unsigned nodeID);

    /// QUEUED ACTION -directly sets the frequency compensation which is used for 
	/// the control of node frequency
    /// in most cases, just use calibrate() instead.
    void setFreqCompensation(double compensation);

    /// QUEUED ACTION -sets the ratio between the matsuoka's oscillator parameters t2 and t1 - time parameters
	/// e.g if you set this to 4, and T1 is 1, then T2 will be 4
	/// this ratio affects waveshape.
	/// The values for t2 and t1 are not set directly since they are set by setNodeFrequency. 
    void setParam_t2Overt1(double val);

    /// QUEUED ACTION - sets the matsuoka's oscillator parameter C (tonic input: mainly controls amplitude)
    void setParam_c(double val);

    /// QUEUED ACTION - sets the matsuoka's oscillator parameter b (adaptation to signal - mainly controls waveshape)
    void setParam_b(double val);

    /// QUEUED ACTION - sets the matsuoka's oscillator parameter g (adaptation between neurons: mainly controls waveshape)
    void setParam_g(double val);

    /// QUEUED ACTION - sets frequency of the node
	/// If inherit=true it also changes child nodes' frequencies, 
    /// proportionally (e.g. if you double the freq of this node, the freqs of the child nodes double too).
	/// (this function assumes that calibrate() has been run more recently than any of the setParam_ methods
    /// otherwise frequency will not be set accurately).
    void setNodeFrequency(unsigned nodeID, double freq, bool inherit);

    /// QUEUED ACTION - sets frequency of the node as a multiple of its parent
    /// node's frequency 	
	/// If inherit=true it also changes child nodes' frequencies, 
    /// proportionally (e.g. if you double the freq of this node, the freqs of the child nodes double too).
	/// (this function assumes that calibrate() has been run more recently than any of the setParam_ methods
	/// otherwise frequency will not be set accurately).
    void setNodeFrequencyMultiple(unsigned nodeID, double multipleOfParent,
         bool inherit);

    /// QUEUED ACTION - sets the phase offset of the node's output (0-1 as proportion of parent's wavelength)
    /// handled via delay
    void setNodePhaseOffset(unsigned nodeID, double phase);

    /// QUEUED ACTION -sets the amplitude of white noise going into the node
    void setNodeSelfNoise(unsigned nodeID, double amount);

    /// QUEUED ACTION -sets synchronisation mode for the node 
	/// - free (no synchronisation), 
	/// - synchOnce - synchronise once (on next zero crossing of parent node, 
	/// this node is also reset to zero crossing state)
	/// - synchLock - (synchronisation happens at *every* parent zero-crossing).
	/// I have not found synchLoc useful. synchOnce is useful e.g. when spawning a new node, 
    void setNodeSynchMode(unsigned nodeID, synchMode mode);

    /// QUEUED ACTION - set input of 1 sample of an external signal to a node
	/// Just 1 sample, so needs to be called every step.
	/// TODO: input-pointer version so you can set and forget.
    void setNodeExternalInput(unsigned nodeID, double weight, double input);

    /// resets the flag that indicates that node parameters have been changed
	/// useful for GUI development
    void resetNodeChangeFlag_Params(unsigned nodeID);
    /// resets the flag that indicates that node inputs have been changed
	/// useful for GUI development
    void resetNodeChangeFlag_Inputs(unsigned nodeID);

    /// sets the grid type for the quantiser for the node
    void setNodeQuantiser_Grid(unsigned nodeID, gridType grid);

    /// sets the multiplier for grid coarseness (defines resolution of grid / no of valid positions on grid)
    void setNodeQuantiser_Multiple(unsigned nodeID, float mult);

    /// sets the offset of the grid - shifts the grid by this many base units
    void setNodeQuantiser_Offset(unsigned nodeID, float off);
    
    /// returns the grid type of the quantiser for the node
    gridType getNodeQuantiser_Grid(unsigned nodeID);

    /// returns the multiplier for grid coarseness (defines resolution of grid / no of valid positions on grid)
    float getNodeQuantiser_Multiple(unsigned nodeID);

    /// returns the offset of the grid (the number of base units the grid is shifted by)
    float    getNodeQuantiser_Offset(unsigned nodeID);

    /// returns the no of base units per "bar" of the grid (a "bar" is 1 cycle of node 0)
    /// set by setNodeQuantiser_Multiple
    unsigned getNodeQuantiser_BarDivision(unsigned nodeID);

    /// sets the strength of quantisation effect (0=no quantisation 1= strict quantisation)
	/// 0 means notes are not affected by the quantiser
	/// 1 means notes are moved to the nearest quantiser grid position
	/// values in between nudge the note towards the nearest grid position, to a greater or lesser degree
    void     setQuantiseAmount(float amount);
	void     setQuantiseAmount(unsigned node, float amount);

    /// gets the strength of quantisation effect (0=no quantisation 1= strict quantisation)
    float    getQuantiseAmount();
	float    getQuantiseAmount(unsigned node);

    /// sets the sample rate (expected no of calculations/outputs per second) - used in internal calculations
    /// (this value should match the number of times per second you call step() per second)
    void setSampleRate(unsigned sampleRate);

    /// clears the network back to single root node (node 0), resets all values to defaults
    void clear();

    /// enacts the requests of methods which are commented  QUEUED ACTION
	/// e.g. applies any queued requests to add nodes, change frequencies, etc.
	/// should be called e.g. once per signal vector, before doing the network calculations.
    void doQueuedActions(); 

    /// sets a callback which will be called for each output event 
	/// for details of output events see class constructor.
    /// calback should take an int (nodeID) and a float (amplitude peak at event)
    void setEventCallback(Callback cb);

    /// tells the engine to shutdown
    void setShutdown(bool shutdown);

    /// (un/)pauses the engine (step() will have no effect while paused
    void setPause(bool pause);

    /// reports true if the system is in the process of shutting down
    bool isShuttingDown();

    /// reports true if not currently calculating a step
    bool isIdle();

    /// The step counter begins at zero on initialisation and increments by one each time step() is called. 
    /// this reports the current value of the step counter
    uint64_t getEngineStepCounter();

	/// Set system to be driven by an external phasor
	/// this allows for synchronisation to e.g. sequencers.
	/// none: the system runs freely
	/// driven: the phasor input drives node 0 directly (signal feedback into node 0 has no effect).
	///		in this mode, node 0 is a wavetable oscillator whose wavetable is one cycle of the oscillator without input
	/// reseting: the phasor calculates as normal, but is reset to its state at positive zero crossing every time the phasor wraps
	///		in this mode signal feedback into node 0 has some limited effect, but the system re-synchronises to input at each bar.
	void setDriven(externalSync driven);

	/// Set value of external driving phasor (drives node0)
	/// needs to be called once per sample if the network is driven (see setDriven())
	void setDrivingInput(float val);

	/// if SetDriven has been called, with value other than "none", this 
	// resets the node to its state just prior to positive zero-crossing 
	// otherwise behaviour is same as reset(nodeID)
	void zeroSync(unsigned nodeID);


private:
    std::mutex _actions_mutex;
    std::mutex _output_mutex;
    uint64_t _stepCounter;

    CPG _cpg;
    std::queue<std::function<void()>> _actions;
    std::vector<outputEvent> _outputs;

    Callback _eventCallback;
    bool _callbackSet;


    enum class CompensationCalcState : char
    {
        WAITING, COUNTING, IDLE
    } _compCalcState;

    std::vector<CPG::input> _fcc_node0Inputs;
    unsigned _fcc_sampleCount;
    unsigned _fcc_cycleCount;
    static constexpr unsigned _fcc_cyclesPerCalc = 4;


    QuantisedEventQueue _quantiser;
    unsigned _sampleRate;
    bool _eventOnRise, _eventOnFall, _fireOnPeak;
    bool _shutdown, _idle, _paused;

    void fillOutputs(); // called at end of step


    void _setSampleRate(unsigned sampleRate);

    void updateFreqCompensationState();
    void doFreqCompensationCalcs();
    void synchroniseChildren(std::vector<unsigned> childIDs);
    void updateQuantiserTempo();

};

